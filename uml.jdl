/**
* In practice we'll extend the actual User class.
* We could just use this as a placeholder for relationships?
*/
entity AppUser {

}

/**
* Used to store calculated data for the Playlist Insights
feature.
* This feature should be usable when not logged in, but
we probably don't want to store the data in that case.
*/
entity PlaylistData {
    spotifyID String required unique
    imageURL String

    avgValence Float
    avgDanceability Float
    avgEnergy Float
    avgAcousticness Float
    length Integer

    lastUpdated Instant required
}

/**
* Used to cache top artists' percentages for Playlist Insights
so it doesn't need to be re-calculated every time.
* Not sure in practice how necessary this is
*/
entity PlaylistArtistProportion {
    percentage Float
}

/**
 * Instance of a song being played.
 */
entity Stream {
    playedAt LocalDate required
}

entity Song {
    spotifyID String required unique minlength(22)
    name String required
    imageURL String
    year LocalDate
    duration Duration

    acousticness Float
    danceability Float
    energy Float
    instrumentalness Float
    key Integer
    liveness Float
    loudness Float
    mode Boolean
    speechiness Float
    tempo Float
    timesignature Integer
    valence Float
}

entity Artist {
    spotifyID String required unique
    name String required
}

/**
 * One-way dated connection from user to another user.
 */
entity Friendship {
    fromDate LocalDate required
}

entity FriendRecommendation {
    similarity Float min(0.0) max(1.0) required
    lastUpdated LocalDate required
}

relationship OneToOne {
    PlaylistArtistProportion{artist} to Artist
    PlaylistArtistProportion{playlist} to PlaylistData{artistProportions}

    Friendship{friend required} to AppUser
    FriendRecommendation{user required} to AppUser
}

relationship OneToMany {
    AppUser{streams} to Stream  // Each user will listen to many songs.

    PlaylistData{tracks} to Song
    AppUser{playlists} to PlaylistData{owner}

    AppUser{friend} to Friendship
    AppUser{friendRecommendation} to FriendRecommendation
    AppUser{blockedUser} to AppUser
}

relationship ManyToOne {
    Stream{playedSong required} to Song{streamEvent}  // Each stream is required to have one song.

    PlaylistData{happiestSong} to Song
    PlaylistData{fastestSong} to Song
    PlaylistData{sumUpSong} to Song
    PlaylistData{anomalySong} to Song
}

relationship ManyToMany {
    Artist{song} to Song{artist}
}
